// [Dusk] Preferences dialog

// Is the preferences menu open?
int g_PreferencesOpen = false;

// Where is the cursor at?
int g_PreferenceCursor = 0;

#define PREFTYPE_POLARENUM 	0 // -1, 0, 1 for low, medium, high
#define PREFTYPE_INT		1 // integer value
#define PREFTYPE_CREDITS	2 // credit value
#define PREFTYPE_BOOL		3 // true/false toggle
#define PREFTYPE_INVBOOL	4 // false/true toggle

#define HID_PREFERENCES 7000

// Increment, minimum and maximum are only used in integer and credit types.
#define PRK_CVAR 0 // CVAR name, will be prefixed with aow_cl_
#define PRK_LABEL 1 // Description of this as appears on the menu
#define PRK_TYPE 2 // Type of this, determines how it is handled in the menu
#define PRK_INCR 3 // How much this variable is incremented at one key press
#define PRK_MIN 4 // Minimum amount of this
#define PRK_MAX 5 // Maximum amount of this
// --
#define MAX_PREFKEYS 6

// =============================================================================
// [Dusk] Preference definitions.
#define MAX_PREFERENCES 7
int g_Preferences[MAX_PREFERENCES][MAX_PREFKEYS];

// =============================================================================
// [Dusk] Definitions have to be in a separate function because otherwise
// there's conflicts.
function void PR_AddPreferenceType (str var, str label, int type, int incr, int min, int max) {
	int i = 0;
	while (g_Preferences[i][PRK_CVAR] != 0)
		i++; // Find a free spot
	if (i >= MAX_PREFERENCES)
		FatalError1f ("Tried to declare too many preferences types! Limit is %d", MAX_PREFERENCES);
	
	g_Preferences[i][PRK_CVAR] = var;
	g_Preferences[i][PRK_LABEL] = label;
	g_Preferences[i][PRK_TYPE] = type;
	g_Preferences[i][PRK_INCR] = incr;
	g_Preferences[i][PRK_MIN] = min;
	g_Preferences[i][PRK_MAX] = max;
}

// =============================================================================
function void PR_InitPreferences (void) {
	if (g_Preferences[0][PRK_CVAR] != 0)
		return;
	
	PR_AddPreferenceType ("fx", "Graphics level", PREFTYPE_POLARENUM, -1, -1, -1);
	PR_AddPreferenceType ("donateamount", "Donation amount", PREFTYPE_CREDITS, 50, 0, 1000);
	PR_AddPreferenceType ("killerhealth", "Show killer's health", PREFTYPE_BOOL, -1, -1, -1);
	PR_AddPreferenceType ("nohud", "Show AOW HUD", PREFTYPE_INVBOOL, -1, -1, -1);
	PR_AddPreferenceType ("alwaysradar", "Team radar", PREFTYPE_BOOL, -1, -1, -1);
	PR_AddPreferenceType ("noteamlog", "Team log", PREFTYPE_INVBOOL, -1, -1, -1);
	PR_AddPreferenceType ("confonthud", "Console font HUD", PREFTYPE_BOOL, -1, -1, -1);
	
	// Check that we have the right amount of preferences
	int i = 0;
	while (g_Preferences[i][PRK_CVAR] != 0)
		i++;
	if (i != MAX_PREFERENCES)
		FatalError2f ("MAX_PREFERENCES set incorrectly, is %d, should be %d\n", i, MAX_PREFERENCES);
}

// =============================================================================
// CCMD: aow_preferencemenu
script SC_PREF_MENUTOGGLE (void) net clientside {
	if (g_PreferencesOpen) {
		PR_Dismiss ();
		terminate;
	}
	
	// Check whether we're eligible to use the pref menu
	if (!PR_CheckValid (consoleplayer))
		terminate;
	
	g_PreferencesOpen = true;
	g_PreferenceCursor = 0;
	LocalAmbientSound ("menu/prompt", 127);
	
	// Request a menu freeze and wait until we get the confirmation.
	ACS_ExecuteAlways (SC_PREF_REQUESTFREEZE, 0, true);
	if (netstate == NETSTATE_Client) // no need to offline, though..
		while (CheckInventory ("InMenu") != MENU_PREFERENCES && g_PreferencesOpen)
			delay (1);
	
	// If the menu was closed while in the above block, get out now.
	if (!g_PreferencesOpen)
		terminate;
	
	PR_Draw ();
	
	do {
		// Menu loop
		int buttons = GetPlayerInput (-1, INPUT_BUTTONS);
		int delaytime = 5;
		
		if (buttons & BT_FORWARD)
			PR_MoveCursor (-1);
		else if (buttons & BT_BACK)
			PR_MoveCursor (1);
		else if (buttons & BT_LEFT || buttons & BT_MOVELEFT)
			PR_MoveCurrent (true);
		else if (buttons & BT_RIGHT || buttons & BT_MOVERIGHT)
			PR_MoveCurrent (false);
		else if (buttons & BT_ATTACK || buttons & BT_ALTATTACK)
			PR_Dismiss ();
		else
			delaytime = 1;
		
		delay (delaytime);
	} while (g_PreferencesOpen);
}

// =============================================================================
// Check are we supposed to be able to be in the preferences menu.
function bool PR_CheckValid (int cp) {
	// Quite unfortunately, we cannot do any menus while spectating, since
	// any button input will not be recorded then.
	if (!PlayerInGame (cp))
		return false;
	
	int menutype = CheckActorInventory (3800 + cp, "InMenu");
	if (menutype != MENU_PREFERENCES && menutype != 0)
		return false; // in another menu
	
	return true;
}

// =============================================================================
function void PR_HUDMessage (str text, int id, int x, int y) {
	HUDMessage (s:text; HUDMSG_PLAIN, HID_PREFERENCES + id, CR_UNTRANSLATED, x, y, 0);
}

// =============================================================================
function void PR_Draw (void) {
	int y = 0.3;
	
	SetFont ("BIGFONT");
	PR_HUDMessage ("\cgPREFERENCES", 0, -0.4, y);
	y += 0.025;
	
	SetHUDFont ();
	
	// Loop through each preference and display it
	for (int i = 0; i < MAX_PREFERENCES; i++) {
		str head_color = "\cR";
		str val_color = "\cU";
		
		int hilight = i == g_PreferenceCursor;
		
		// Use different colors when highlighting the specific preference
		if (hilight) {
			head_color = "\cG";
			val_color = "\cJ";
		}
		
		// Label of the preference
		PR_HudMessage (strparam (s:head_color, s:g_Preferences[i][PRK_LABEL], s:":"), (i * 2) + 1, -0.4, y);
		
		// Now build the value string
		int val = GetCVar (strparam (s:"aow_cl_", s:g_Preferences[i][PRK_CVAR]));
		str type = g_Preferences[i][PRK_TYPE];
		str text;
		
		// Determine how to show the value to the user
		switch (type) {
		case PREFTYPE_BOOL:
		case PREFTYPE_INVBOOL:
			if (type == PREFTYPE_INVBOOL)
				val = !val;
			
			if (hilight)
				val_color = cond (val, "\cD", "\cQ");
			else
				val_color = cond (val, "\cC", "\cU");
			text = strparam (s:val_color, s:cond (val, "ON", "OFF"));
			break;
		case PREFTYPE_INT:
			text = strparam (s:val_color, d:val);
			break;
		case PREFTYPE_CREDITS:
			str fmt = "\cQ$\cD";
			if (!hilight)
				fmt = "\cM$\cU";
			
			text = strparam (s:fmt, d:val);
			break;
		case PREFTYPE_POLARENUM:
			if (val < 0) {
				text = "LOW";
				val_color = cond (hilight, "\cG", "\cR");
			} else if (val == 0) {
				text = "NORMAL";
				val_color = cond (hilight, "\cF", "\cK");
			} else {
				text = "HIGH";
				val_color = cond (hilight, "\cD", "\cQ");
			}
			break;
		}
		
		PR_HudMessage (strparam (s:val_color, s:text), (i * 2) + 2, -0.6, y);
		y += SMALLSPACE;
	}
}

// =============================================================================
// Un-draw the preferences
function void PR_Undraw (void) {
	ClearHUDMessage (HID_PREFERENCES); // header
	for (int i = 0; i < MAX_PREFERENCES; i++) {
		ClearHUDMessage (HID_PREFERENCES + (i * 2) + 1);
		ClearHUDMessage (HID_PREFERENCES + (i * 2) + 2);
	}
}

// =============================================================================
// Move current preference to positive or to negative.
function void PR_MoveCurrent (int neg) {
	int cur = g_PreferenceCursor;
	str type = g_Preferences[cur][PRK_TYPE];
	str cvar = strparam (s:"aow_cl_", s:g_Preferences[cur][PRK_CVAR]);
	int val = GetCVar (cvar);
	str cmd = strparam (s:"set ", s:cvar);
	
	switch (type) {
	case PREFTYPE_BOOL:
	case PREFTYPE_INVBOOL:
		if (val)
			cmd = strparam (s:cmd, s:" 0");
		else
			cmd = strparam (s:cmd, s:" 1");
		break;
	case PREFTYPE_INT:
	case PREFTYPE_CREDITS:
		int newval = val + (cond (neg, -1, 1) * g_Preferences[cur][PRK_INCR]);
		int min = g_Preferences[cur][PRK_MIN];
		int max = g_Preferences[cur][PRK_MAX];
		if (newval < min)
			newval = min;
		else if (newval > max)
			newval = max;
		
		cmd = strparam (s:cmd, s:" ", d:newval);
		break;
	case PREFTYPE_POLARENUM:
		newval = val + cond (neg, -1, 1);
		if (newval > 1)
			newval -= 3;
		if (newval < -1)
			newval += 3;
		cmd = strparam (s:cmd, s:" ", d:newval);
	}
	
	ConsoleCommand (cmd);
	LocalAmbientSound ("menu/change", 127);
	PR_Draw ();
}

// =============================================================================
// Move the preference cursor delta entries down.
function void PR_MoveCursor (int delta) {
	g_PreferenceCursor += delta;
	
	if (g_PreferenceCursor >= MAX_PREFERENCES)
		g_PreferenceCursor %= MAX_PREFERENCES;
	
	while (g_PreferenceCursor < 0)
		g_PreferenceCursor += MAX_PREFERENCES;
	
	LocalAmbientSound ("menu/cursor", 127);
	PR_Draw ();
}

// =============================================================================
function void PR_Dismiss (void) {
	if (!g_PreferencesOpen)
		return;
	
	g_PreferencesOpen = false;
	PR_Undraw ();
	ACS_ExecuteAlways (804, 0, false);
	LocalAmbientSound ("menu/dismiss", 127);
}

// =============================================================================
script SC_PREF_REQUESTFREEZE (int set) clientside {
	if (!PR_CheckValid (consoleplayer))
		terminate;
	
	// Because there is no client->server packet loss countering, we keep
	// performing the request until it passes through.
	do {
		Puke1 (SC_PREF_FREEZECMD, set);
		delay (15);
	} while (g_PreferencesOpen == set && CheckInventory ("InMenu") != cond (set, MENU_PREFERENCES, 0));
}

// =============================================================================
// Serverside: client requests to be frozen while they pick their preferences.
script SC_PREF_FREEZECMD (int set) net {
	if (!PR_CheckValid (PlayerNumber ()))
		terminate;
	
	// Set the properties
	SetPlayerProperty (0, set, PROP_FROZEN);
	SetPlayerProperty (0, set, PROP_TOTALLYFROZEN);
	SetInventory ("InMenu", cond (set, MENU_PREFERENCES, 0));
}